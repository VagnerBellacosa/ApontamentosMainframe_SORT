[z/OS](https://www.ibm.com/docs/en/zos)[2.1.0](https://www.ibm.com/docs/en/zos/2.1.0)

[Feedback](mailto:ibmdocs@us.ibm.com?Subject=Feedback to IBM Documentation&body=URL: https%3A%2F%2Fwww.ibm.com%2Fdocs%2Fen%2Fzos%2F2.1.0%3Ftopic%3Dse-example-15-sort-64-bit-parameter-lists-e15-e35-outfil)[Product list](https://www.ibm.com/docs/en/products)

![img](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/zoshead.gif) **z/OS DFSORT Application Programming Guide** ![img](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/zosspot.gif)

| [Previous topic](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/ice2ca_Example_14._Sort_with_IFTHEN.htm) \| [Next topic](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/ice2ca_Merge_examples.htm) \| [Contents](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/toc.htm) \| [Contact z/OS](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zcontact.doc/webqs.html) \| [Library](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.ice/ice.htm) \| [PDF](http://publibz.boulder.ibm.com/epubs/pdf/ice2ca00.pdf)  ![img](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/c.gif) Example 15. Sort with 64-bit parameter lists, E15, E35 and OUTFIL  z/OS DFSORT Application Programming Guide SC23-6878-00 |
| ------------------------------------------------------------ |
| ![img](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/dblue_rule.gif)INPUTVariable-length records from E15OUTPUTVariable-length output data setWORK DATA SETSDynamically allocated (by default)USER EXITSE15 and E35FUNCTIONS/OPTIONS64-bit parameter lists, OUTFILThe JCL for running program PGM1, and the code used by PGM1 to invoke DFSORT with the 64-bit invocation parameter list and use the 64-bit E15 and E35 parameter lists, are shown below.`//EXAMP    JOB A400,PROGRAMMER                                  01 //STEP1    EXEC PGM=PGM1                                        02 //SYSOUT   DD SYSOUT=A                                          03 //SORTOUT  DD DSN=PL64.OUTPUT,DISP=(NEW,CATLG,DELETE),          04 //  SPACE=(CYL,(8,4)),UNIT=SYSDA                                05 ----------------------------------------------------------------------- ----------------------------------------------------------------------- PGM1     CSECT                                                  06 PGM1     AMODE 64 PGM1     RMODE 31         STM   14,12,12(13)        SAVE LOW PART REGS         BASR  15,0                SET THE TEMPORARY         USING *,15                 BASE REG M0       DS    0H         STMH  0,15,HIGHREGS       SAVE HIGH PART REGS         LLGTR 12,15               SET THE PERMANENT         DROP  15                   BASE         USING M0,12                 REG         LMH   0,15,HIGHZERO       SET HIGH PART OF REGS TO ZERO         ST    13,SAVE+4           SAVE SAVE AREA ADDR         LR    11,13               RELOAD SAVE AREA ADDR         LA    13,SAVE             LOAD NEW SAVE AREA ADDR         ST    13,8(11)            SAVE NEW SA ADDR INTO OLD SA * Obtain 64-bit storage (memory object): * - for 64-bit Invocation Parameter List * - for 64-bit Control Statements Area * - for work area passed to E15, E35 exits via USER ADDRESS CONSTANT         STG   12,MOTOKEN          SAVE USERTOKEN         LA    2,2                 SET NUMBER OF SEGMENTS         STG   2,MOSEGM             FOR MEMORY OBJECT (MO) - 2MB         IARV64 REQUEST=GETSTOR,   GET MEMORY OBJECT                   +               ORIGIN=MOADDR,      ADDRESS OF MEMORY OBJECT            +               USERTKN=MOTOKEN,    USERTOKEN                           +               SEGMENTS=MOSEGM,    SIZE OF MEMORY OBJECT               +               COND=YES,           CONDITIONAL REQUEST                 +               MF=(E,MOWORK)         LTR   15,15               IF MEMORY OBJECT NOT OBTAINED,         BNZ   NOMO                 EXIT WITH ERROR RETURN CODE         LG    10,MOADDR           GET 64-BIT ADDR IN MO FOR *                                   64-BIT INVOCATION PARMLIST         USING ICE64INV,10         MAKE ADDRESSABLE         XC    0(ICE64LNG,10),0(10) CLEAR 64-BIT INVOCATION PARM LIST         MVC   ICEPLID(8),PL64SORT MOVE 64-BIT PARM LIST IDENTIFIER         LA    2,1024(,10)         GET 64-BIT ADDR IN MEMORY OBJECT *                                   FOR 64-BIT CONTROL STATEMENTS AREA         STG   2,ICECTL              AND STORE IN 64-BIT PARM LIST         MVC   0(CTLNG,2),CTLST    MOVE CONTROL STATEMENTS INTO MO *         LA    2,1024(,2)          GET 64-BIT ADDR IN MO FOR WORK AREA         STG   2,MOWA               USED IN E15, E35 EXITS         MVC   ICEUC(8),UADCON     MOVE USER EXIT ADDRESS CONSTANT *         LLGF  2,=A(E15)           STORE E15 ADDR         STG   2,ICE15E32           INTO PARM LIST         OI    ICEMDEX1,ICE15A64     WITH AMODE 64 AND         OI    ICEMDEX2,ICE15PLT      WITH 64-BIT EXEC PARAMETER LIST *         LLGF  2,=A(E35)           STORE E35 ADDR         STG   2,ICE35              INTO PARM LIST         OI    ICEMDEX1,ICE35A64     WITH AMODE 64 AND         OI    ICEMDEX2,ICE35PLT      WITH 64-BIT EXEC PARAMETER LIST *                                   INTO 64-BIT INVOCATION PARM LIST         LGR   1,10                LOAD ADDR OF 64-BIT INVOCATION *                                   PARAMETER LIST         LINK  EP=SORT64           INVOKE SORT WITH 64-BIT NAME         LR    11,15               SAVE RETURN CODE FREEMO   DS    0H         IARV64 REQUEST=DETACH,      FREE MEMORY OBJECT                +               MATCH=USERTOKEN,                                        +               USERTKN=MOTOKEN,                                        +               COND=YES,                                               +               MF=(E,MOWORK)         LR    15,11              RESTORE RETURN CODE * EXITALL  DS    0H         LMH   0,14,HIGHREGS      RESTORE HIGH PART REGS         L     13,SAVE+4          RESTORE OLD SA ADDR         L     14,12(13)          RESTORE CALLER'S         LM    1,12,24(13)         REGS         BSM   0,14               RETURN TO CALLER * NOMO     LA    15,20              ERROR RETURN CODE (NOT MO)         B     EXITALL            RETURN TO CALLER * SAVE     DC    18F'0'              SAVE AREA HIGHREGS DC    16F'0' HIGHZERO DC    16F'0' * CTLST    DS    0H                  ADDR OF CONTROL STMTS         DC    AL2(CTL2-CTL1)      LENGTH OF CONTROL STATEMENT STRING CTL1     EQU   *         DC    C' SORT FIELDS=(5,4,BI,A)'         DC    C' RECORD LENGTH=(80,80,80),TYPE=V '         DC    C' OPTION FILSZ=E1000 '         DC    C' OUTFIL FNAMES=SORTOUT ' CTL2     EQU   * CTLNG    EQU   *-CTLST             LENGTH OF CONTROL STATEMENTS AREA PL64SORT DC    C'PL64SORT'         IDENTIFIER OF 64-BIT PARM LIST UADCON   DC    F'0',A(MOWA)        USER ADDRESS CONSTANT MOWA     DC    D'0'                ADDR OF WORK AREA IN MO * MOTOKEN  DC    D'0'                USERTOKEN MOSEGM   DC    D'0'                SIZE OF MO (IN MB) MOADDR   DC    D'0'                ADDR OF MO * MOWORK   DS    0D                  IARV64 MACRO WORK AREA         IARV64 MF=(L,MOV64L) *         LTORG *         ICEPL64                   MAPPING OF 64-BIT PARM LISTS *         DROP  12 PGM1     CSECT ************** E15 ********************************************** * E15      DS    0H * THIS E15 EXIT ROUTINE FORMS ALL RECORDS IN MEMORY OBJECT * AND INSERTS THEM TO DFSORT AS 64-BIT ADRESSED RECORDS. *         STMG  14,12,8(13)        SAVE CALLER's REGISTERS         BASR  11,0               SET         USING *,11                ADDRESSABILITY         LLGTR 11,11              SET CLEAN BASE REG         LARL  14,SAVEE15         GET NEW SAVE AREA ADDRESS         STG   13,128(,14)        CHAIN TO PREVIOUS SAVE AREA         STG   14,136(,13)        CHAIN TO NEW SAVE AREA         LGR   13,14              SET R13 TO SAVE AREA ADDRESS         LMH   0,15,E15HZERO      SET HIGH PART OF REGS TO ZERO         LR    10,1               SAVE EXIT PARAMETER LIST ADDRESS         USING ICE64E15,10        SET ADDRESSABILITY         ICM   15,15,COUNT        EXIT IF ALL RECORDS WERE         BZ    EOF                 INSERTED         LLGF  1,ICE15UC+4        GET USER CONSTANT ADDR         LG    1,0(1)             GET ADDR OF THE WORK AREA IN MO         MVC   0(80,1),RECE15     MOVE RECORD INTO MEMORY OBJECT         BCTR  15,0               SET NEW         ST    15,COUNT            SORT FIELD *         LA    15,12              RC=12 (INSERT RECORD) * RETURN TO DFSORT BACKE15  DS    0H         LG    13,128(,13)        RESTORE CALLER's R13         LG    14,8(,13)          RESTORE CALLER's R14         LMG   2,12,40(13)        RESTORE CALLER's R2-R12         BSM   0,14               RETURN * EOF      DS    0H * Create final record in MO for its insert to DFSORT as 64-bit * addressed record in the E35 exit         LLGF  15,ICE15UC+4       GET USER CONSTANT ADDR         LG    15,0(15)           GET ADDR IN MO FOR FINAL RECORD         XC    0(80,15),0(15)     CLEAR RECORD's DATA         MVI   1(15),8            SET NEW LENGTH OF FINAL RECORD         MVC   4(4,15),RECNUM     SET 'NUMBER OF INSERTED RECORDS'         LA    15,8               SET RETURN CODE         B     BACKE15            RETURN CODE * E15HZERO DC    18F'0' SAVEE15  DC    0D'0',F'0',C'F4SA',17FD'0' HIGHE15  DC    16F'0' FLAGE15  DC    X'00' E15MOADR DC    D'0'               ADDR OF MO E15SEGM  DC    D'0'               SIZE OF MO (IN MB) E15TOKEN DC    D'0'               USERTOKEN RECNUM   DC    F'1000'            NUMBER OF RECORDS RECE15   DC    H'80'              LENGTH OF RECORD         DC    H'0' COUNT    DC    F'1000'            SORT FIELD         DC    6C'ABCDEF'         DATA         DC    6C'123456'          FIELDS *         LTORG *         DROP PGM1     CSECT ************** E35 ******************************************** E35      DS    0H * * THIS E35 EXIT ACCEPTS ALL RECORDS FROM DFSORT * AND AT EOF INSERTS ONE RECORD TO DFSORT AS 64-BIT RECORD. * THE ADDRESS OF THE FINAL RECORD IN MEMORY OBJECT IS PASSED * VIA USER ADDRESS CONSTANT FIELD OF 64-BIT PARAMETER LIST. *         STMG  14,12,8(13)        SAVE CALLER's REGISTERS         BASR  11,0               SET         USING *,11                ADDRESSABILITY         LLGTR 11,11              SET CLEAN BASE REG         LARL  14,SAVEE35         GET NEW SAVE AREA ADDRESS         STG   13,128(,14)        CHAIN TO PREVIOUS SAVE AREA         STG   14,136(,13)        CHAIN TO NEW SAVE AREA         LGR   13,14              SET R13 TO SAVE AREA ADDRESS         LMH   0,15,E35HZERO      SET HIGH PART REGS TO ZERO         LR    10,1               SAVE EXIT PARM LIST ADDRESS         USING ICE64E35,10        SET ADDRESSABILITY         ICM   1,15,ICE35RL+4     GET ADDR OF NEW RECORD * IF ADDR OF NEW RECORD IT IS ZERO, EOF IS INDICATED         BZ    RC8E35             BR IF EOF *         LA    15,0               'ACCEPT' RETURN CODE * RETURN TO DFSORT BACKE35  DS    0H         LG    13,128(,13)        RESTORE CALLER's R13         LG    14,8(,13)          RESTORE CALLER's R14         LMG   2,12,40(13)        RESTORE CALLER's R2-R12         BSM   0,14               RETURN * RC8E35   DS    0H         TM    FLAGE35,X'01'      IF FINAL FLAG IS ON         BO    RC8E35A             EXIT WITH 8 RETURN CODE         MVI   FLAGE35,X'01'      SET FINAL FLAG         LLGF  1,ICE35UC+4         GET USER CONSTANT ADDR         LG    1,0(1)             GET MO ADDR WITH FINAL RECORD         LA    15,12              SET 'INSERT' RETURN CODE         B     BACKE35            RETURN TO DFSORT RC8E35A  DS    0H         LA    15,8               SET RETURN CODE         B     BACKE35            RETURN TO DFSORT * E35HZERO DC    18F'0' HIGHE35  DC    18F'0' SAVEE35  DC    0D'0',F'0',C'F4SA',17FD'0' FLAGE35  DC    X'00' *         LTORG *         END`**Line****Explanation**01JOB statement. Introduces this job to the operating system.02EXEC statement. Calls a program named PGM1 that in turn calls DFSORT.03SYSOUT DD statement. Directs DFSORT messages and control statements to SYSOUT class A.04-05SORTOUT DD statement. The OUTFIL data set.06Start of the complete source code for PGM1. PGM1 uses the ICEPL64 mapping macro in the DFSORT target library, SICEUSER, to provide separate Assembler DSECTs for the 64-bit invocation and exit parameter lists.PGM1 LINKs to DFSORT using the name SORT64 to indicate that it is using the 64-bit invocation parameter list. PGM1 passes SORT, RECORD, OPTION and OUTFIL statements in the control statement area.PGM1's E15 user exit passes 64-bit addressed records to DFSORT.PGM1's E35 user exit accepts all of the sorted records and inserts one additional record at EOF. DFSORT writes all of the records to the OUTFIL data set.**Parent topic:**[Sort examples](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/ice2ca_Sort_examples.htm)[![Go to the previous page](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/pageback.gif)](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/ice2ca_Example_14._Sort_with_IFTHEN.htm) ![img](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/pagemid.gif) [![Go to the next page](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/pagenext.gif)](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/ice2ca_Merge_examples.htm) |



[Notices](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zaddinfo.doc/notices.html) | [Terms of use](http://www.ibm.com/legal/us/) | [Support](http://www.ibm.com/servers/eserver/zseries/zos/support/) | [Contact z/OS](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zcontact.doc/webqs.html) | [zFavorites](http://www-03.ibm.com/systems/z/os/zos/library/zfavorites/)   ![img](https://www.ibm.com/docs/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.icea100/copyright.gif)Copyright IBM Corporation 1990, 2014





PreviousExample 14. Sort with IFTHEN

NextMERGE examples

Was this topic helpful?

YesNo



### 







### 















### 







### 



© Copyright IBM Corporation 2017, 2021